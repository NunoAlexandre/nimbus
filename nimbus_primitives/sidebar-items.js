window.SIDEBAR_ITEMS = {"constant":[["INHERENT_IDENTIFIER","The InherentIdentifier for nimbus’s author inherent"],["NIMBUS_ENGINE_ID","The ConsensusEngineId for nimbus consensus this same identifier will be used regardless of the filters installed"],["NIMBUS_KEY_ID","The KeyTypeId used in the Nimbus consensus framework regardles of wat filters are in place. If this gets well adopted, we could move this definition to sp_core to avoid conflicts."]],"mod":[["digests","A convenient interface over the digests used in nimbus."]],"struct":[["InherentDataProvider","A bare minimum inherent data provider that provides no real data. The inherent is simply used as a way to kick off some computation until https://github.com/paritytech/substrate/pull/10128 lands."],["IntervalBeacon","PLANNED: A SlotBeacon that starts a new slot based on the timestamp. Behaviorally, this is similar to what aura, babe and company do. Implementation-wise it is different because it depends on the timestamp pallet for its notion of time."]],"trait":[["AccountLookup","A Trait to lookup runtime AccountIds from AuthorIds (probably NimbusIds) The trait is generic over the AccountId, becuase different runtimes use different notions of AccoutId. It is also generic over the AuthorId to support the usecase where the author inherent is used for beneficiary info and contains an AccountId directly."],["CanAuthor","Trait to determine whether this author is eligible to author in this slot. This is the primary trait your nimbus filter needs to implement."],["DigestsProvider",""],["EventHandler","The given account ID is the author of the current block."],["NimbusApi","The runtime api used to predict whether a Nimbus author will be eligible in the given slot"],["SlotBeacon","A mechanism for determining the current slot. For now we use u32 as the slot type everywhere. Let’s see how long we can get away with that."]],"type":[["NimbusId","A nimbus author identifier (A public key)."],["NimbusPair","A nimbus keypair"],["NimbusSignature","A nimbus signature."]]};